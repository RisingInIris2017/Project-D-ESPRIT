function [varargout] = array_manifold_generator(number_of_subarray, antenna_in_subarray, doa_vector)    % 各子阵内第i个阵元对第1号阵元的位移应已知    % 为简单起见，令各子阵均为线阵，且相邻阵元间隔载波的半波长。    % 这样略去设置载波波长，不失一般性。    % 这里k取遍一切值时，zeta_k_i不变化；    % 当需要zeta_k_i向量时，取该矩阵的第i列即可。    zeta_k_i=[0:antenna_in_subarray-1;zeros(1,antenna_in_subarray)];    % 假设1号子阵的1号阵元位于(0,0)    % 生成第k个子阵的1号阵元相对于(0,0)的位移zeta_k    % 它们应为随机，不为系统所知    % 为简单起见，令zeta_k的分量为载波的半波长整数倍。    % 这样略去设置载波波长，不失一般性。    zeta_k = [zeros(2,1),randi(4,2,number_of_subarray-1)];        for k = 1:number_of_subarray        % 计算Phi_k(theta, zeta_k)        eval("Phi_"+num2str(k)+"=[];")        for l = 1:length(doa_vector)            eval("Phi_"+num2str(k)+"=[Phi_"+num2str(k)+" "+num2str(phi_calc(doa_vector(l),zeta_k(:,k)))+"];")        end        % 化为对角矩阵        eval("Phi_"+num2str(k)+"=diag("+"Phi_"+num2str(k)+");")        % 计算V_k(theta)        % 由于各个子阵均相同，zeta_k_i不变化，显然所有的V矩阵都相同。        eval("V_"+num2str(k)+"=[];")        for l = 1:length(doa_vector)            eval("V_"+num2str(k)+"=[V_"+num2str(k)+" "+mat2str(vk_calc(doa_vector(l),zeta_k_i))+"];")        end        % 计算阵列流形Ak        eval("A_"+num2str(k)+"=V_"+num2str(k)+"*Phi_"+num2str(k)+";");        eval("varargout{k}=A_"+num2str(k)+";");    endend